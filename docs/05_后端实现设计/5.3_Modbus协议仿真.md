# Modbus协议仿真设计

## 概述

本文档描述Modbus TCP协议仿真器的具体实现设计，包括指令接收、解析、处理和应答的完整流程。

## 核心流程

### 1. 指令接收 (Command Reception)

#### TCP连接管理
```
┌─────────────┐    TCP Connect    ┌─────────────┐
│ Modbus客户端 │ ───────────────> │   仿真器     │
│             │                  │             │
│             │ <─────────────── │             │
└─────────────┘    TCP Accept    └─────────────┘
```

#### 接收流程
1. **监听端口**: 在配置的端口上启动TCP监听器
2. **接受连接**: 接受客户端连接请求
3. **数据接收**: 持续接收客户端发送的Modbus TCP数据帧
4. **帧完整性检查**: 验证接收到的数据帧是否完整

#### 关键实现点
- 使用异步TCP监听器处理多个客户端连接
- 每个连接维护独立的接收缓冲区
- 处理TCP粘包/分包问题，确保完整的Modbus帧

### 2. 指令解析 (Command Parsing)

#### Modbus TCP帧结构
```
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│Transaction ID (2) │Protocol ID (2)│Length(2)│Unit ID│Function│Data   │
│                  │               │         │  (1)  │Code(1) │(N)    │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
```

#### 解析步骤
1. **MBAP头部解析**
   - Transaction ID: 事务标识符
   - Protocol ID: 协议标识符 (固定为0)  
   - Length: 后续字节长度
   - Unit ID: 单元标识符 (从机地址)

2. **PDU解析**
   - Function Code: 功能码
   - Data: 功能码相关数据

#### 支持的功能码（仅读操作）
| 功能码 | 名称 | 描述 |
|--------|------|------|
| 01 | Read Coils | 读取线圈状态 |
| 02 | Read Discrete Inputs | 读取离散输入 |
| 03 | Read Holding Registers | 读取保持寄存器 |
| 04 | Read Input Registers | 读取输入寄存器 |

#### 地址基准与示例 (功能码03)
```
请求: 03 00 01 00 02  (PDU起始地址=1，0基；对应逻辑地址=40001+1=40002)
│     │  │     │
│     │  │     └── 数量 (2个寄存器)
│     │  └───────── 起始地址 (地址1)
│     └──────────── 功能码 (03-读保持寄存器)
└────────────────── (前面还有MBAP头部)
```

### 3. 指令处理 (Command Processing)

#### 处理流程
```
指令解析 → 从机地址验证 → 地址范围检查 → 数据操作 → 构建响应
```

#### 从机地址验证
1. 检查Unit ID是否在配置的从机列表中
2. 如果从机不存在，返回相应错误码

#### 地址范围检查
1. 根据功能码确定寄存器类型
2. 检查起始地址和数量是否在有效范围内
3. 验证是否有对应的寄存器配置

#### 数据操作
**读操作流程**:
```
1. 根据从机ID和起始地址查询数据库
2. 获取寄存器配置的hexdata字段
3. 解析16进制字符串为字节数组
4. 提取请求范围内的数据
5. 构建读取响应数据
```

### 4. 应答生成 (Response Generation)

#### 应答数据来源与Plan B（按地址范围推断类型）

**1. 数据库配置**
查找逻辑：根据功能码推断寄存器类型与单位长度，然后选出覆盖请求范围的数据块。

- 功能码01/02（位类型：线圈/离散输入）
  - 单位：位；存储为字节串（hexdata每2个hex=1字节=8位）
  - 覆盖范围计算：块覆盖位数 = (len(hexdata)/2)*8
- 功能码03/04（寄存器类型：HR/IR）
  - 单位：寄存器（16位=2字节）；存储为寄存器串（hexdata每4个hex=1个寄存器）
  - 覆盖范围计算：块覆盖寄存器数 = (len(hexdata)/4)

可实现为：先在应用层按功能码计算覆盖范围并筛选出与 [请求起始逻辑地址, 请求结束逻辑地址) 相交的数据块，再做精确截取。

**2. 数据处理逻辑**
```
数据库hexdata: "0011223344556677"
起始地址: 100
请求地址: 101, 数量: 2

处理:
1. 计算偏移: (101-100) * 4 = 4个十六进制字符
2. 提取数据: hexdata[4:12] = "22334455"  
3. 转换为响应: [0x22, 0x33, 0x44, 0x55]
```

#### 响应帧构建（显式大端序）

**成功响应结构**:
```
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│Transaction ID (2) │Protocol ID (2)│Length(2)│Unit ID│Function│Data   │
│     (回显)        │      (0)      │         │  (1)  │Code(1) │       │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
```

**错误响应结构**:
```
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│Transaction ID (2) │Protocol ID (2)│Length(2)│Unit ID│Func+0x80│Error│
│     (回显)        │      (0)      │   (3)   │  (1)  │   (1)   │Code │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────┘
```

#### 常见错误码
| 错误码 | 名称 | 说明 |
|--------|------|------|
| 01 | 非法功能码 | 不支持的功能码（仅支持01-04读操作）|
| 02 | 非法数据地址 | 地址超出范围 |
| 04 | 从设备故障 | 从设备无法处理请求 |

### 5. 读取数量计算

**线圈/离散输入 (功能码01/02)**:
```
请求数量: N个线圈
响应字节数: (N + 7) / 8  // 每字节8个位
响应格式: [字节数] + [数据字节...]
```

**寄存器 (功能码03/04)**:
```
请求数量: N个寄存器  
响应字节数: N * 2      // 每个寄存器2字节
响应格式: [字节数] + [寄存器数据...]
```

**示例**:
```
读取2个保持寄存器 (功能码03):
请求: 03 00 01 00 02
响应: 03 04 12 34 56 78
     │  │  │─────────┘
     │  │  └── 2个寄存器的数据 (0x1234, 0x5678)
     │  └───── 数据字节数 (4字节)
     └────────── 功能码 (03)
```

## 实现架构

### 协议类型支持

#### Modbus TCP
- 标准Modbus TCP协议，使用MBAP头部
- 适用于以太网环境的Modbus通信

#### Modbus RTU over TCP  
- 将RTU格式的Modbus帧封装在TCP中传输
- 包含CRC校验，适用于串口转TCP的场景

### 核心类设计
```csharp
public class ModbusTcpService : IProtocolHandler
{
    public string ProtocolType => "ModbusTCP";

    public async Task<byte[]> ProcessRequestAsync(byte[] request, ProtocolContext context)
    {
        var frame = ParseModbusTcpFrame(request);
        
        if (frame.FunctionCode < 1 || frame.FunctionCode > 4)
        {
            return BuildErrorResponse(frame.TransactionId, frame.Slaveid, (byte)(frame.FunctionCode + 0x80), 0x01);
        }

        var responsePdu = await HandleReadFunctionAsync(frame, context);
        return BuildResponseFrame(frame.TransactionId, frame.Slaveid, frame.FunctionCode, responsePdu);
    }

    private ModbusTcpFrame ParseModbusTcpFrame(byte[] request)
    {
        ushort ReadUInt16BE(ReadOnlySpan<byte> buf, int offset) => (ushort)((buf[offset] << 8) | buf[offset + 1]);
        
        var transactionId = ReadUInt16BE(request, 0);
        var protocolId = ReadUInt16BE(request, 2);
        var length = ReadUInt16BE(request, 4);
        var slaveid = request[6];
        var functionCode = request[7];
        var data = request.Skip(8).ToArray();
        
        return new ModbusTcpFrame
        {
            TransactionId = transactionId,
            Slaveid = slaveid,
            FunctionCode = functionCode,
            Data = data
        };
    }

    private byte[] BuildResponseFrame(ushort transactionId, byte slaveid, byte functionCode, byte[] responseData)
    {
        void WriteUInt16BE(List<byte> dst, ushort value)
        {
            dst.Add((byte)(value >> 8));
            dst.Add((byte)(value & 0xFF));
        }

        var response = new List<byte>(7 + 1 + responseData.Length);
        WriteUInt16BE(response, transactionId);
        WriteUInt16BE(response, 0); // Protocol ID
        WriteUInt16BE(response, (ushort)(responseData.Length + 2)); // PDU length
        response.Add(slaveid);
        response.Add(functionCode);
        response.AddRange(responseData);
        return response.ToArray();
    }

    private byte[] BuildErrorResponse(ushort transactionId, byte slaveid, byte errorFunctionCode, byte errorCode)
    {
        void WriteUInt16BE(List<byte> dst, ushort value)
        {
            dst.Add((byte)(value >> 8));
            dst.Add((byte)(value & 0xFF));
        }

        var pdu = new byte[] { errorFunctionCode, errorCode };
        var response = new List<byte>(7 + pdu.Length);
        WriteUInt16BE(response, transactionId);
        WriteUInt16BE(response, 0);
        WriteUInt16BE(response, (ushort)(pdu.Length + 1));
        response.Add(slaveid);
        response.AddRange(pdu);
        return response.ToArray();
    }
}

public class ModbusTcpFrame
{
    public ushort TransactionId { get; set; }
    public byte Slaveid { get; set; }
    public byte FunctionCode { get; set; }
    public byte[] Data { get; set; }
}

public class ModbusRtuOverTcpService : IProtocolHandler
{
    public string ProtocolType => "ModbusRTU";

    public async Task<byte[]> ProcessRequestAsync(byte[] request, ProtocolContext context)
    {
        return await ProcessRtuFrame(request);
    }
}
```

### 数据映射策略
1. **直接映射**: 寄存器地址直接对应数据库记录
2. **范围映射**: 一个数据库记录包含连续的寄存器范围
3. **稀疏映射**: 支持不连续的寄存器地址配置

地址基准（统一规则）：
- 数据库存储的 `startaddr` 使用逻辑1基地址：
  - 线圈：00001–09999
  - 离散输入：10001–19999
  - 输入寄存器：30001–39999
  - 保持寄存器：40001–49999
- 协议PDU中的起始地址为0基偏移：
  - FC01: 逻辑地址 = 00001 + offset
  - FC02: 逻辑地址 = 10001 + offset
  - FC04: 逻辑地址 = 30001 + offset
  - FC03: 逻辑地址 = 40001 + offset

Plan B（不新增列）：按逻辑地址区间推断类型，位型以字节串存储（2hex=1byte），寄存器型以寄存器串存储（4hex=1reg）。位型偏移按位计算并在响应按字节打包。

### 性能优化
1. **连接池**: 复用数据库连接
2. **数据缓存**: 缓存频繁访问的寄存器数据
3. **异步处理**: 使用异步I/O处理并发请求
4. **内存池**: 复用字节数组减少GC压力

## 总结

Modbus协议仿真器专注于读操作的仿真实现，通过TCP监听接收客户端请求，解析Modbus帧获取功能码和数据，仅处理功能码01-04的读取操作。根据配置的从机和寄存器信息生成相应的响应数据，最后构建标准的Modbus TCP响应帧返回给客户端。

**设计限制**：
- 仅支持读操作（功能码01-04）
- 不支持任何写操作（功能码05/06/15/16等）
- 专注于数据展示和仿真测试场景

整个过程严格遵循Modbus TCP协议规范中的读取部分，确保与标准Modbus客户端的读操作兼容性。
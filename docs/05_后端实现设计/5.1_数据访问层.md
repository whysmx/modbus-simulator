# 后端数据访问层实现

本文档详细说明API接口如何从数据库中获取数据，以及Repository模式的具体实现。

## 数据访问架构

```
API Controllers → Business Services → Repository Layer → SQLite Database
```

## 业务服务层接口设计

业务服务层位于Controller和Repository之间，负责处理业务逻辑、数据验证和协调多个Repository的操作：

### 连接服务接口

```csharp
public interface IConnectionService
{
    // 获取连接树结构（包含从机信息）
    Task<IEnumerable<ConnectionTree>> GetConnectionsTreeAsync();
    
    // 创建连接（包含业务验证）
    Task<Connection> CreateConnectionAsync(CreateConnectionRequest request);
    
    // 更新连接（包含端口冲突检查）
    Task<Connection> UpdateConnectionAsync(string id, UpdateConnectionRequest request);
    
    // 删除连接（级联删除从机和寄存器）
    Task DeleteConnectionAsync(string id);
}
```

### 从机服务接口

```csharp
public interface ISlaveService
{
    // 创建从机（包含地址唯一性验证）
    Task<Slave> CreateSlaveAsync(string connectionId, CreateSlaveRequest request);
    
    // 更新从机（包含地址冲突检查）
    Task<Slave> UpdateSlaveAsync(string connectionId, string slaveId, UpdateSlaveRequest request);
    
    // 删除从机（级联删除寄存器）
    Task DeleteSlaveAsync(string connectionId, string slaveId);
}
```

### 寄存器服务接口

```csharp
public interface IRegisterService
{
    // 获取寄存器列表（扁平列表；按地址区间由前端分类）
    Task<IEnumerable<Register>> GetRegistersBySlaveIdAsync(string slaveId);
    
    // 创建寄存器组（包含地址冲突检查）
    Task<Register> CreateRegisterAsync(string connectionId, string slaveId, CreateRegisterRequest request);
    
    // 更新寄存器组（包含数据格式验证）
    Task<Register> UpdateRegisterAsync(string connectionId, string slaveId, string registerId, UpdateRegisterRequest request);
    
    // 删除寄存器组
    Task DeleteRegisterAsync(string connectionId, string slaveId, string registerId);
}
```

```

## Repository 接口设计

基于数据库设计中的三张核心表（connections、slaves、registers），实现对应的Repository接口：

### Repository 接口设计（严格按照03_API接口规范.md）

```csharp
// 连接Repository：严格对应03_API接口规范.md中的4个接口
public interface IConnectionRepository
{
    Task<Connection> CreateAsync(Connection connection);            // POST /connections
    Task<Connection> UpdateAsync(Connection connection);            // PUT /connections/{id}
    Task DeleteAsync(string id);                                  // DELETE /connections/{id}
    Task<IEnumerable<ConnectionTree>> GetConnectionsTreeAsync();    // GET /connections/tree
}

// 从机Repository：严格对应03_API接口规范.md中的3个接口
public interface ISlaveRepository
{
    Task<Slave> CreateAsync(Slave slave);                                  // POST /connections/{id}/slaves
    Task<Slave> UpdateAsync(Slave slave);                                  // PUT /connections/{id}/slaves/{slaveId}
    Task DeleteAsync(string id);                                          // DELETE /connections/{id}/slaves/{slaveId}
}

// 寄存器Repository：严格对应03_API接口规范.md中的4个接口
public interface IRegisterRepository
{
    Task<IEnumerable<Register>> GetBySlaveIdAsync(string slaveId);     // GET /connections/{id}/slaves/{slaveId}/registers
    Task<Register> CreateAsync(Register register);                     // POST /connections/{id}/slaves/{slaveId}/registers
    Task<Register> UpdateAsync(Register register);                     // PUT /connections/{id}/slaves/{slaveId}/registers/{regId}
    Task<bool> DeleteAsync(string id);                                // DELETE /connections/{id}/slaves/{slaveId}/registers/{regId}
}
```

## SQLite 数据访问实现

使用 **Dapper** 进行轻量级的数据访问实现：

### ConnectionRepository 实现示例

```csharp
public class ConnectionRepository : IConnectionRepository
{
    private readonly IDbConnection _connection;
    
    public ConnectionRepository(IDbConnection connection)
    {
        _connection = connection;
    }
    
    public async Task<Connection> CreateAsync(Connection connection)
    {
        connection.Id = Guid.NewGuid().ToString("N"); // 32位无横杠UUID
        
        // 后端自动分配端口（从502开始）
        connection.Port = await GetNextAvailablePortAsync();
        
        const string sql = @"
            INSERT INTO connections (id, name, port) 
            VALUES (@Id, @Name, @Port);";
        
        await _connection.ExecuteAsync(sql, connection);
        return connection;
    }
    
    // 私有方法：获取下一个可用端口
    private async Task<int> GetNextAvailablePortAsync()
    {
        const string sql = "SELECT MAX(port) FROM connections";
        var maxPort = await _connection.QuerySingleOrDefaultAsync<int?>(sql);
        
        // 从502开始，或者从最大端口+1开始
        return maxPort.HasValue ? maxPort.Value + 1 : 502;
    }
    
    public async Task<Connection> UpdateAsync(Connection connection)
    {
        // 在更新时直接进行验证，有错误就抛出对应异常
        var existingCount = await _connection.QuerySingleAsync<int>(
            "SELECT COUNT(1) FROM connections WHERE id = @Id", new { Id = connection.Id });
        if (existingCount == 0)
            throw new KeyNotFoundException("连接不存在");
        
        var portInUse = await _connection.QuerySingleAsync<int>(
            "SELECT COUNT(1) FROM connections WHERE port = @Port AND id != @Id", 
            new { Port = connection.Port, Id = connection.Id });
        if (portInUse > 0)
            throw new InvalidOperationException("端口已被使用");
        
        const string sql = @"
            UPDATE connections 
            SET name = @Name, port = @Port 
            WHERE id = @Id;";
        
        await _connection.ExecuteAsync(sql, connection);
        return connection;
    }
    
    public async Task DeleteAsync(string id)
    {
        const string sql = "DELETE FROM connections WHERE id = @Id";
        var affected = await _connection.ExecuteAsync(sql, new { Id = id });
        if (affected == 0)
            throw new KeyNotFoundException("资源不存在");
    }
    

    
    // 关键方法：高效获取连接树结构
    public async Task<IEnumerable<ConnectionTree>> GetConnectionsTreeAsync()
    {
        const string sql = @"
            SELECT
                c.id AS Id, c.name AS Name, c.port AS Port,
                s.id AS Id, s.connid AS Connid, s.name AS Name, s.slaveid AS Slaveid
            FROM connections c
            LEFT JOIN slaves s ON c.id = s.connid
            ORDER BY c.name, s.slaveid";
        
        var connectionDict = new Dictionary<string, ConnectionTree>();
        
        await _connection.QueryAsync<Connection, Slave, ConnectionTree>(
            sql,
            (connection, slave) =>
            {
                if (!connectionDict.TryGetValue(connection.Id, out var connectionTree))
                {
                    connectionTree = new ConnectionTree
                    {
                        Id = connection.Id,
                        Name = connection.Name,
                        Port = connection.Port,
                        Slaves = new List<Slave>()
                    };
                    connectionDict[connection.Id] = connectionTree;
                }
                
                if (slave != null && !string.IsNullOrEmpty(slave.Id))
                {
                    connectionTree.Slaves.Add(slave);
                }
                
                return connectionTree;
            },
            splitOn: "Id"  // 指向从机部分的第一列（Id）
        );
        
        return connectionDict.Values;
    }
}
```
> 注意：使用 Dapper 进行多对象映射时，建议显式控制 SELECT 列顺序与别名，使 `splitOn` 对应的第一列准确指向第二对象的切分列，避免 `Id`、`Name` 等重复列名导致歧义。可选择将从机列改为如 `s.id AS SlaveId` 并设置 `splitOn: "SlaveId"`。

### 其他Repository实现

SlaveRepository 和 RegisterRepository 的实现模式类似，主要包含基础的CRUD操作和业务验证方法。具体实现可参考ConnectionRepository的模式。

## API Controller 实现（严格按照03_API接口规范.md）

每个Controller只实现03_API接口规范.md中定义的接口，不额外添加任何方法。Controller专注于HTTP请求处理，业务逻辑委托给Service层。

树与寄存器加载约定：
- `GET /api/connections/tree` 仅返回两层（连接、从机），不包含寄存器明细，减少首屏数据量；
- 当前端展开某个从机时，通过 `GET /api/connections/{id}/slaves/{slaveId}/registers` 懒加载该从机下全部寄存器组，前端按地址区间分类补齐第三层节点。

### ConnectionsController

```csharp
[ApiController]
[Route("api/[controller]")]
public class ConnectionsController : ControllerBase
{
    private readonly IConnectionService _connectionService;
    
    public ConnectionsController(IConnectionService connectionService)
    {
        _connectionService = connectionService;
    }
    
    // POST /api/connections - 创建连接
    [HttpPost]
    public async Task<ActionResult<Connection>> CreateConnection([FromBody] CreateConnectionRequest request)
    {
        try
        {
            var created = await _connectionService.CreateConnectionAsync(request);
            return StatusCode(201, created);
        }
        catch (ArgumentException ex)
        {
            return BadRequest(new { error = ex.Message, code = 400 });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { error = ex.Message, code = 400 });
        }
    }
    
    // PUT /api/connections/{id} - 更新连接
    [HttpPut("{id}")]
    public async Task<ActionResult<Connection>> UpdateConnection(string id, [FromBody] UpdateConnectionRequest request)
    {
        try
        {
            var updated = await _connectionService.UpdateConnectionAsync(id, request);
            return Ok(updated);
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { error = ex.Message, code = 400 });
        }
    }
    
    // DELETE /api/connections/{id} - 删除连接
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteConnection(string id)
    {
        try
        {
            await _connectionService.DeleteConnectionAsync(id);
            return NoContent();
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
    }
    
    // GET /api/connections/tree - 获取连接+从机树结构
    [HttpGet("tree")]
    public async Task<ActionResult<IEnumerable<ConnectionTree>>> GetConnectionsTree()
    {
        var connectionTrees = await _connectionService.GetConnectionsTreeAsync();
        return Ok(connectionTrees);
    }
}
```

### SlavesController

```csharp
[ApiController]
[Route("api/connections/{connectionId}/slaves")]
public class SlavesController : ControllerBase
{
    private readonly ISlaveService _slaveService;
    
    public SlavesController(ISlaveService slaveService)
    {
        _slaveService = slaveService;
    }
    
    // POST /api/connections/{connectionId}/slaves - 创建从机
    [HttpPost]
    public async Task<ActionResult<Slave>> CreateSlave(string connectionId, [FromBody] CreateSlaveRequest request)
    {
        try
        {
            var created = await _slaveService.CreateSlaveAsync(connectionId, request);
            return StatusCode(201, created);
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { error = ex.Message, code = 400 });
        }
    }
    
    // PUT /api/connections/{connectionId}/slaves/{slaveId} - 更新从机
    [HttpPut("{slaveId}")]
    public async Task<ActionResult<Slave>> UpdateSlave(string connectionId, string slaveId, [FromBody] UpdateSlaveRequest request)
    {
        try
        {
            var updated = await _slaveService.UpdateSlaveAsync(connectionId, slaveId, request);
            return Ok(updated);
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { error = ex.Message, code = 400 });
        }
    }
    
    // DELETE /api/connections/{connectionId}/slaves/{slaveId} - 删除从机
    [HttpDelete("{slaveId}")]
    public async Task<IActionResult> DeleteSlave(string connectionId, string slaveId)
    {
        try
        {
            await _slaveService.DeleteSlaveAsync(connectionId, slaveId);
            return NoContent();
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
    }
}
```

### RegistersController

```csharp
[ApiController]
[Route("api/connections/{connectionId}/slaves/{slaveId}/registers")]
public class RegistersController : ControllerBase
{
    private readonly IRegisterService _registerService;
    
    public RegistersController(IRegisterService registerService)
    {
        _registerService = registerService;
    }
    
    // GET /api/connections/{connectionId}/slaves/{slaveId}/registers - 获取寄存器列表
    [HttpGet]
    public async Task<ActionResult<IEnumerable<Register>>> GetRegisters(string connectionId, string slaveId)
    {
        try
        {
            var registers = await _registerService.GetRegistersBySlaveIdAsync(slaveId);
            return Ok(registers);
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
    }
    
    // POST /api/connections/{connectionId}/slaves/{slaveId}/registers - 创建寄存器组
    [HttpPost]
    public async Task<ActionResult<Register>> CreateRegister(string connectionId, string slaveId, [FromBody] CreateRegisterRequest request)
    {
        try
        {
            var created = await _registerService.CreateRegisterAsync(connectionId, slaveId, request);
            return StatusCode(201, created);
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { error = ex.Message, code = 400 });
        }
    }
    
    // PUT /api/connections/{connectionId}/slaves/{slaveId}/registers/{registerId} - 更新寄存器组
    [HttpPut("{registerId}")]
    public async Task<ActionResult<Register>> UpdateRegister(string connectionId, string slaveId, string registerId, [FromBody] UpdateRegisterRequest request)
    {
        try
        {
            var updated = await _registerService.UpdateRegisterAsync(connectionId, slaveId, registerId, request);
            return Ok(updated);
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(new { error = ex.Message, code = 400 });
        }
    }
    
    // DELETE /api/connections/{connectionId}/slaves/{slaveId}/registers/{registerId} - 删除寄存器组
    [HttpDelete("{registerId}")]
    public async Task<IActionResult> DeleteRegister(string connectionId, string slaveId, string registerId)
    {
        try
        {
            await _registerService.DeleteRegisterAsync(connectionId, slaveId, registerId);
            return NoContent();
        }
        catch (KeyNotFoundException ex)
        {
            return NotFound(new { error = ex.Message, code = 404 });
        }
    }
}
```

## 依赖注入配置

在 `Program.cs` 中配置依赖注入：

```csharp
// 启用Dapper字段命名映射（数据库蛇形命名→C#帕斯卡命名）
Dapper.DefaultTypeMap.MatchNamesWithUnderscores = true;

// 数据库连接
builder.Services.AddScoped<IDbConnection>(provider =>
{
    var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
    return new SqliteConnection(connectionString);
});

// Repository 注册
builder.Services.AddScoped<IConnectionRepository, ConnectionRepository>();
builder.Services.AddScoped<ISlaveRepository, SlaveRepository>();
builder.Services.AddScoped<IRegisterRepository, RegisterRepository>();

// 业务服务层注册
builder.Services.AddScoped<IConnectionService, ConnectionService>();
builder.Services.AddScoped<ISlaveService, SlaveService>();
builder.Services.AddScoped<IRegisterService, RegisterService>();

// TCP服务和协议处理器
builder.Services.AddSingleton<TcpServer>();
builder.Services.AddSingleton<IProtocolHandler, ModbusTcpService>();
```

## 错误处理策略

1. **数据库连接异常**: 返回500状态码，记录详细日志
2. **业务验证失败**: 返回400状态码，提供具体错误信息
3. **资源不存在**: 返回404状态码
4. **SQL约束违反**: 解析异常类型，返回相应的业务错误

## 性能优化建议

1. **连接池**: 使用SQLite连接池管理
2. **异步操作**: 所有数据库操作使用async/await
3. **参数化查询**: 防止SQL注入，提高查询效率
4. **索引优化**: 基于查询模式优化数据库索引
5. **批量操作**: 对于批量数据操作，使用事务处理

## 数据一致性保证

1. **外键约束**: 利用SQLite的外键约束保证数据关联完整性
2. **唯一约束**: 通过数据库唯一约束和业务验证双重保证
3. **事务处理**: 对于涉及多表操作的业务，使用数据库事务
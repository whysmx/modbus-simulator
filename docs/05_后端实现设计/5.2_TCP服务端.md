# TCP服务端设计文档

## 概述

本文档描述Modbus仿真器的TCP服务端核心架构设计。TCP服务端负责网络通信层面的处理，通过协议处理器接口支持多种协议实现。

## 设计目标

- **多端口监听**: 支持在多个TCP端口上同时提供服务
- **并发处理**: 能够同时处理多个客户端连接  
- **协议抽象**: 通过接口支持多种协议（Modbus TCP、Modbus RTU over TCP等）
- **简洁实用**: 避免过度设计，保持架构简单可维护

## 核心架构

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                       TCP服务端                              │  
│  ┌─────────────────────┐                                    │
│  │     TcpServer       │                                    │
│  │                     │                                    │
│  │ • 端口监听           │                                    │
│  │ • 连接管理           │                                    │ 
│  │ • 并发处理           │                                    │
│  └─────────┬───────────┘                                    │
└────────────┼────────────────────────────────────────────────┘
             │ IProtocolHandler
             ▼
┌─────────────────────────────────────────────────────────────┐
│                     协议处理层                               │
│  ┌─────────────────────┐  ┌─────────────────────┐           │
│  │  ModbusTcpService   │  │   其他协议处理器     │           │
│  │                     │  │   (可扩展)          │           │
│  └─────────────────────┘  └─────────────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

## 核心组件设计

### 1. TcpServer - TCP服务端

#### 职责
- 在指定端口启动TCP监听器
- 接受并管理客户端连接
- 处理TCP数据流的接收和发送
- 调用协议处理器处理业务逻辑

#### 核心功能
```csharp
public class TcpServer
{
    private readonly IProtocolHandler _protocolHandler;
    
    // 启动多端口监听
    public async Task StartAsync(int[] ports);
    
    // 停止指定端口的监听
    public async Task StopAsync(int port);
    
    // 处理单个客户端连接
    private async Task HandleClientAsync(TcpClient client);
}
```

### 2. IProtocolHandler - 协议处理接口

#### 职责
- 定义协议处理的统一接口
- 处理协议特定的解析和响应逻辑
- 支持多协议扩展

#### 核心接口
```csharp
public interface IProtocolHandler
{
    // 处理协议请求，返回响应数据（携带上下文）
    Task<byte[]> ProcessRequestAsync(byte[] request, ProtocolContext context);
    
    // 获取协议类型标识
    string ProtocolType { get; }
}

public sealed class ProtocolContext
{
    public string ConnectionId { get; init; }   // 由端口映射得到
    public int LocalPort { get; init; }
    public EndPoint RemoteEndPoint { get; init; }
}
```

## 实现示例

### TcpServer 实现
```csharp
public class TcpServer
{
    private readonly IProtocolHandler _protocolHandler;
    private readonly ConcurrentDictionary<int, TcpListener> _listeners = new();
    private readonly ConcurrentDictionary<int, string> _portToConnectionId = new();
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    
    public TcpServer(IProtocolHandler protocolHandler)
    {
        _protocolHandler = protocolHandler;
    }
    
    // 启动多端口监听（端口→连接ID映射）
    public async Task StartAsync(Dictionary<int, string> portToConnectionId)
    {
        foreach (var kv in portToConnectionId)
        {
            _portToConnectionId[kv.Key] = kv.Value;
        }
        var tasks = portToConnectionId.Keys.Select(StartListenerAsync);
        await Task.WhenAll(tasks);
    }
    
    // 启动单个端口监听
    private async Task StartListenerAsync(int port)
    {
        var listener = new TcpListener(IPAddress.Any, port);
        _listeners[port] = listener;
        listener.Start();
        
        while (!_cancellationTokenSource.Token.IsCancellationRequested)
        {
            try
            {
                var client = await listener.AcceptTcpClientAsync();
                _ = Task.Run(() => HandleClientAsync(port, client), _cancellationTokenSource.Token);
            }
            catch (ObjectDisposedException)
            {
                break; // 监听器已停止
            }
        }
    }
    
    // 处理单个客户端连接
    private async Task HandleClientAsync(int port, TcpClient client)
    {
        using var networkStream = client.GetStream();
        var buffer = new byte[1024];
        var context = new ProtocolContext
        {
            LocalPort = port,
            ConnectionId = _portToConnectionId.TryGetValue(port, out var id) ? id : null,
            RemoteEndPoint = client.Client.RemoteEndPoint
        };
        
        try
        {
            while (client.Connected && !_cancellationTokenSource.Token.IsCancellationRequested)
            {
                var bytesRead = await networkStream.ReadAsync(buffer, 0, buffer.Length);
                if (bytesRead == 0) break;
                
                // 提取实际数据
                var request = new byte[bytesRead];
                Array.Copy(buffer, 0, request, 0, bytesRead);
                
                // 调用协议处理器（携带上下文）
                var response = await _protocolHandler.ProcessRequestAsync(request, context);
                
                // 发送响应
                await networkStream.WriteAsync(response, 0, response.Length);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"客户端连接处理错误: {ex.Message}");
        }
        finally
        {
            client?.Close();
        }
    }
    
    // 停止指定端口的监听
    public async Task StopAsync(int port)
    {
        if (_listeners.TryRemove(port, out var listener))
        {
            listener.Stop();
            _portToConnectionId.TryRemove(port, out _);
        }
    }
    
    // 停止所有监听
    public async Task StopAllAsync()
    {
        _cancellationTokenSource.Cancel();
        foreach (var listener in _listeners.Values) listener.Stop();
        _listeners.Clear();
        _portToConnectionId.Clear();
    }
}
```

### ModbusTcpService 实现示例
```csharp
public class ModbusTcpService : IProtocolHandler
{
    public string ProtocolType => "ModbusTCP";
    
    public async Task<byte[]> ProcessRequestAsync(byte[] request, ProtocolContext context)
    {
        // Modbus协议解析和处理逻辑
        // 详见 docs/05_后端实现设计/5.3_Modbus协议仿真.md
        return await ProcessModbusRequestAsync(request);
    }
    
    private async Task<byte[]> ProcessModbusRequestAsync(byte[] request)
    {
        // 具体的Modbus协议处理实现
        // 包括帧解析、功能码处理、数据操作、响应构建
        // ...
        return new byte[0]; // 实际实现中返回响应数据
    }
}
```

## 使用示例

### 服务启动配置
```csharp
// Program.cs 中的配置示例
var builder = WebApplication.CreateBuilder(args);

// 注册协议处理器
builder.Services.AddSingleton<IProtocolHandler, ModbusTcpService>();

// 注册TCP服务端
builder.Services.AddSingleton<TcpServer>();

var app = builder.Build();

// 启动TCP服务端（端口→连接ID）
var tcpServer = app.Services.GetRequiredService<TcpServer>();
// 实际项目中可从数据库 connections 表读取映射
var portMap = new Dictionary<int, string>
{
    [502] = "0123456789abcdef0123456789abcdef",
    [503] = "fedcba9876543210fedcba9876543210"
};
await tcpServer.StartAsync(portMap);

await app.RunAsync();
```

## 协议扩展支持

通过实现`IProtocolHandler`接口，可以轻松扩展支持其他协议：

```csharp
// 扩展支持Modbus RTU over TCP
public class ModbusRtuOverTcpService : IProtocolHandler
{
    public string ProtocolType => "ModbusRTU";
    
    public async Task<byte[]> ProcessRequestAsync(byte[] request, ProtocolContext context)
    {
        // RTU协议特定的处理逻辑
        // 包括CRC校验、RTU帧格式等
        return await ProcessRtuRequestAsync(request);
    }
}
```

## 总结

简化后的TCP服务端架构专注于核心功能：

- **网络层职责明确**：TcpServer专注TCP连接管理和数据传输
- **协议层抽象清晰**：通过IProtocolHandler接口支持多协议扩展  
- **实现简单实用**：避免过度抽象，代码易理解和维护
- **并发性能良好**：异步I/O模型支持多客户端并发访问
- **扩展性充分**：协议处理器可插拔，支持不同工业协议

具体的Modbus协议实现细节请参考：`docs/05_后端实现设计/5.3_Modbus协议仿真.md`